# Introduction

This document has all my thoughts and solutions to whatever difficulties I encountered while working with Hono, HTMX, Template Engines and Web Components. There will be subsections for each TODO item from the README.md file so feel free to skip around and maybe learn something new!

## Working with configs

So this is the first time I actually started to work with a package.json file for real and not just letting the Vite npm install handle everything for me, like for instance that you need to actually transpile your .ts files for the browser to understand as well as let the node server have access to your files directory. A lot of man hours spent on this but at least I know better know that you need a bundler for your Javascript code and that the browser only understands that + there is a package called [concurrency](https://stackoverflow.com/questions/30950032/how-can-i-run-multiple-npm-scripts-in-parallel) that allows for scripts to run in parallel which is nice especially if you want to watch the build bundle file, the DX isn't that nice though so I looked into how Hono can play along with the browser and they do have Vite support as well. All is well, I have a dev server with HMR and I don't need to build every change and I don't need to refresh the browser for wanting to see me changes, but instead use the index.ts file like it normally would in development and the server HMRs! I'm actually kinda proud of not only understanding how the browser works but I could also improve my own DX from it as well.

## Working with Web Components

### ShadowDOM
Working with shadow dom templates allows for slots to be used which simplifies the dev experience by a whole lot but it's encapsulated and I can't use tailwind css. If I don't have a shadowdom then I can pass children can cause some design issue but I can use tailwind css. The problem is not that I can't place my tags however I like since the children are in an array I would need to re-arrange them. I can use the `insertBefore()` function which then requires me to get look in to `childNodes` array but there has to be a more efficient way 'cos if I do decide to add another child the array will change maybe querySelectors? `insertAdjacentElement()` seems promising but doesn't work with Nodes. If I want to use it would need to style the creating element in the following way `divEl.classList.add('p-1', 'border-solid', 'border-2', 'border-cyan-800');` which is kinda cumbersome and doesn't provide a good DX. I found out the best solution to be something like this when inserting the Web Components template `this.insertBefore(template.content.cloneNode(true), document.querySelector("#cool-div-tag2"));`, I would be required to name the tags in a smart way and pass it in as a prop or something. The shadow dom has no access to the light dom so querySelectors can only be found inside the shadow root, this makes the DX a bit better in the sense that there is no need to be smart with the id naming as to avoid changing the wrong element.

### Lifecycle hooks  
There are lifecycle methods but they are pretty straight forward so no worries there. connectedCallBack is the onMount, disconnectedCallback is the onDestroy and attributeChangedCallback is the willUpdate. If you want to observer props then a static observer is in order that has an array of values to be observed. Web components requires a fair bit of js knowledge to get working well and to be honest this is where I'm lacking. The attributeChangedCallback is called before the connectedCallback function so if I want to pass props to the Web Component I would need to process the props inside the attributeChangedCallback function and not the constructor since the props aren't accessible there.

### Adding tailwind css to Web Components ShadowDOM
I'm not gonna bore you with this one, it doesn't work. You need to work with the light dom instead but then you lose the ability to use templates as well as slots, this could worsen your DX since now you actually need to ensure that all ids for each HTML-tag is actually unique and don't clash. There are solutions like adding them at run time but that is... no... don't do it... keep it at build time.

### Lazy Loading Web Components
You can also lazy load your web components using this [repo](https://github.com/bholmesdev/vite-conf-islands-arch/tree/main). This was a true trail and error run, I spent so much time trying to implement this and I learn one thing, don't just copy code but understand it. I had trouble rendering web components, I had trouble with HTMX 'cos I tried using a chainsaw my way to a solution when working with [Astro's Island Architecture]((https://github.com/withastro/astro/tree/cf993bc263b58502096f00d383266cd179f331af/packages/astro/src/runtime/client)). So what did I learn? Well I don't know JavaScript what I knew was frameworks and let me tell you they do solve a lot of problems and hide a lot of the ugliness when working with JS. There isn't a lot of implementations and problem solving to share since most of this is something you learn by doing. I used a chainsaw for my needle problem but as I refined the problem statement and tried to understand what it is I want to do as well as understanding JS better, I'm pretty satisfied with my Astro implementation. Do I understand all of the problems I faced? Nope, but I feel like working with web components and VanillaJS has helped me become a better programmer and not a tool user. So if there's anything I learnt from this, it is that I will only use VanillaJS for my personal projects but will most likely still use something like Svelte and React for customers.

## Understanding JS/TS
I didn't know that declaring a variable inside a file would make it global, it allows for a global state manager which is cool actually. But it doesn't work when exporting a default, I lose the ability to have global variables. So to keep everything within a file, I could either work with defaults or use namespaces but defaults seem better so to say.

## Understanding Template engines
They are likes JSX but not type safe. It's JavaScript inside HTML that looks like HTML after it's been processed/compiled which is nice for web development. My initial idea after looking at JSX with disgust was to rendering dynamic html, 'cos I didn't know you could include a part of a html file like it's JSX. So I'm at a cross roads, either create my own template engine (maybe in the future), use JSX (ew) or find battled tested template engine. The ones I found were the following [Mustache.js](https://mustache.github.io/mustache.5.html) which works with cloud workers, something I don't use or plan on using atm. [Nunjucks.js](https://mozilla.github.io/nunjucks/) which is a powerful tool that looks really similar to how [django templates their html](https://docs.djangoproject.com/en/5.0/topics/templates/) and then there's also [ETA](https://eta.js.org/) which is really similar to [EJS](https://ejs.co/) but better according to reddit. Then there's [handlebars](https://handlebarsjs.com/)... I've only read what the internet says and they aren't happy to work with it. And then there's [SquirrellyJS](https://squirrelly.js.org/) which seems to be as powerful as EJS and as light as Mustache.js and it's DX seems to be the cleanest. 

### Implementing my own Template Engine Middleware

The documentation for [SquirrellyJS](https://squirrelly.js.org/) isn't the best... Implementing the middleware was a pain 'cos the error handling for wrong file paths was wrong. Let me explain, when trying to render a HTML file with SquirrellyJS it would throw and error if the file at that path didn't exist what was confusing was if you were to `ctrl+click` the file it does exist, the issue wasn't the file path but SquirrellyJS read that file path, SquirrellyJS doesn't convert escaped characters. So when using ``__dir`` and `resolve` the `\`-characters come along and throw an error, to solve this I would need to wrote this little code snippet `resolve(root).replace(/\\/g, '\\')`. I will most likely create some pull request for either error handling or implement the edge case of having escaped characters in a file path + adding some more documentation wouldn't hurt from my end. If I decide to use SquirrellyJS I most likely will not 'cos Hono's JSX is type safe compared template engines.

### Understanding SquirrellyJS
There are some cheat sheets, they have the normal ifs, loops and the such. But the best part of SquirrellyJS is their `{{@extendsFile('path/to/layout')}}` command. With extendsFile the engine will only reload the contents that differ like Honos JSX render. Then we have the `{{@block('foo')}}` command that can add new variables and you reference them using the `{{#foo}}` command in the extended files. 